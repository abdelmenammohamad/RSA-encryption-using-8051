C51 COMPILER V9.60.7.0   MATH                                                              12/20/2025 19:22:43 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE MATH
OBJECT MODULE PLACED IN .\Objects\math.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE math.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\math
                    -.lst) TABS(2) OBJECT(.\Objects\math.obj)

line level    source

   1          // math.c 
   2          #include "math.h"
   3          #include "config.h" // Includes uint32_t
   4          
   5          /* ================= Modular Exponentiation ================= */
   6          //Computes (base^exp) % mod using square-and-multiply
   7          uint16_t mod_exp(uint16_t base, uint16_t exp, uint16_t mod) // Changed return type to uint16_t
   8          {   
   9   1          char exp_size=16;
  10   1          uint32_t result;
  11   1          if(exp==0) return (uint16_t)1;
  12   1          
  13   1          //move the MSB of exp till it react max index
  14   1          while(!(exp & 0x8000)){
  15   2            exp=exp<<1;
  16   2            exp_size=exp_size-1;
  17   2          }
  18   1          
  19   1          //for MSB in exp
  20   1          result=base;
  21   1          exp=exp<<1;
  22   1          //for the rest of the bits
  23   1          while( (exp!=0) && (exp_size>0) ){
  24   2            result=(result*result)%mod;
  25   2            if((exp & 0x8000)) result=(result*base)%mod;
  26   2            exp=exp<<1;
  27   2            exp_size=exp_size-1;
  28   2          }
  29   1          
  30   1          return result;
  31   1      }
  32          
  33          /* ================= GCD ================= */
  34          /* Euclidean Algorithm */
  35          uint16_t gcd(uint16_t a, uint16_t b) // Changed return type to uint16_t for consistency
  36          {
  37   1          uint16_t temp;
  38   1      // ... (rest of the function is correct) ...
  39   1          while (b != 0)
  40   1          {
  41   2              temp = b;
  42   2              b = a % b;
  43   2              a = temp;
  44   2          }
  45   1          return a;
  46   1      }
  47          
  48          /* ================= Modular Inverse ================= */
  49          /* Extended Euclidean Algorithm (iterative) */
  50          /* ================= Modular Inverse ================= */
  51          /* Extended Euclidean Algorithm (iterative) */
  52          uint16_t mod_inverse(uint16_t e, uint16_t phi) 
  53          {
  54   1          long t = 0;
C51 COMPILER V9.60.7.0   MATH                                                              12/20/2025 19:22:43 PAGE 2   

  55   1          long newt = 1;
  56   1          long r = phi;     // Initial remainder 0 is phi
  57   1          long newr = e;    // Initial remainder 1 is e
  58   1          long q, tmp;
  59   1      
  60   1          // The loop continues until the remainder becomes 0
  61   1          while (newr != 0) {
  62   2              q = r / newr; // Calculate quotient
  63   2      
  64   2              // Update t and newt (coefficients)
  65   2              tmp = newt;
  66   2              newt = t - (q * newt);
  67   2              t = tmp;
  68   2      
  69   2              // Update r and newr (remainders)
  70   2              tmp = newr;
  71   2              newr = r - (q * newr);
  72   2              r = tmp;
  73   2          }
  74   1      
  75   1          // After the loop, r should be the GCD. If GCD > 1, no inverse exists.
  76   1          if (r > 1) return 0; 
  77   1      
  78   1          // Ensure the result is positive
  79   1          if (t < 0) {
  80   2              t = t + phi;
  81   2          }
  82   1      
  83   1          return (uint16_t)t; // Cast back to 16-bit for RSA key structure
  84   1      }
  85          
  86          /* ================= fermat_test ================= */
  87          
  88          uint8_t fermat_test(uint8_t x) {
  89   1          // 1. Basic cases: 0, 1 are not prime; 2, 3 are prime
  90   1          if (x <= 1) return FALSE;
  91   1          if (x == 2 || x == 3) return TRUE;
  92   1          
  93   1          // 2. Even numbers greater than 2 are not prime
  94   1          if (x % 2 == 0) return FALSE;
  95   1      
  96   1          // 3. Fermat's Little Theorem: a^(n-1) = 1 (mod n)
  97   1          // We use base 2 for the calculation
  98   1          if (mod_exp(2, x - 1, x) == 1) {
  99   2              return TRUE;
 100   2          }
 101   1      
 102   1          return FALSE;
 103   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    582    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      37
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
