C51 COMPILER V9.60.7.0   MAIN                                                              12/22/2025 22:31:04 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\main
                    -.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          #include <reg51.h>
   2          #include "uart.h"
   3          #include "RSA.h"
   4          #include "math.h"
   5          #include "config.h"
   6          
   7          /* Hardware Definitions */
   8          sbit MODE_PIN = P3^3;         // 0 = Setup, 1 = Operation
   9          sbit OP_PIN   = P3^4;         // 0 = Encrypt, 1 = Decrypt
  10          sbit ERROR_LED = P2^0;        // Primality Error
  11          sbit E_ERROR_LED = P2^1;      // GCD Error
  12          
  13          RSA_Key key;
  14          uint8_t setup_done = FALSE;   // Global flag to track initialization
  15          
  16          void handle_setup(void) {
  17   1          uint8_t p_val, q_val;
  18   1          uint16_t e_val;
  19   1          
  20   1          // Prevent re-running if already configured
  21   1          if (setup_done == TRUE) return;
  22   1      
  23   1          // 1. Loop for P: continues until valid prime is received
  24   1          while (1) {
  25   2              p_val = uart_receive_decimal(); 
  26   2              if (fermat_test(p_val) == TRUE) {
  27   3                  ERROR_LED = 0;
  28   3                  uart_send_byte(' '); //clear the buffer, due to a problem with the first send_byte
  29   3                  uart_send_byte('P'); 
  30   3                  break; 
  31   3              } else {
  32   3                  ERROR_LED = 1;
  33   3                  uart_send_byte('R'); 
  34   3              }
  35   2          }
  36   1      
  37   1          // 2. Loop for Q: continues until valid prime is received
  38   1          while (1) {
  39   2              q_val = uart_receive_decimal(); 
  40   2              if (fermat_test(q_val) == TRUE) {
  41   3                  ERROR_LED = 0;
  42   3                  uart_send_byte('Q'); 
  43   3                  break; 
  44   3              } else {
  45   3                  ERROR_LED = 1;
  46   3                  uart_send_byte('R'); 
  47   3              }
  48   2          }
  49   1      
  50   1          // 3. Loop for E and Final Key Gen
  51   1          while (1) {
  52   2              e_val = (uint16_t)uart_receive_decimal(); 
  53   2              if (rsa_generate_key(p_val, q_val, e_val, &key) == TRUE) {
  54   3                  E_ERROR_LED = 0;
C51 COMPILER V9.60.7.0   MAIN                                                              12/22/2025 22:31:04 PAGE 2   

  55   3                  uart_send_byte('E'); 
  56   3                  uart_send_byte('O'); 
  57   3                  uart_send_byte('K');
  58   3                  setup_done = TRUE; // Mark setup as complete permanently
  59   3                  break; 
  60   3              } else {
  61   3                  E_ERROR_LED = 1; 
  62   3                  uart_send_byte('R'); 
  63   3              }
  64   2          }
  65   1      }
  66          
  67          void main(void) {
  68   1          uint16_t data_in, data_out;
  69   1      
  70   1          uart_init();
  71   1          ERROR_LED = 0;
  72   1          E_ERROR_LED = 0;
  73   1      
  74   1          while (1) {
  75   2              if (MODE_PIN == 0) {
  76   3                  // Setup Mode: Only runs if setup_done is FALSE
  77   3                  if (setup_done == FALSE) {
  78   4                      handle_setup();
  79   4                  }
  80   3              } else {
  81   3                  // Operation Mode: Only active if setup has been completed once
  82   3                  if (setup_done == TRUE) {
  83   4                      if (OP_PIN == 0) {
  84   5                          /* Encrypt Mode */
  85   5                          // Receive 1 byte (0-255) to encrypt
  86   5                          data_in = (uint16_t)uart_receive_byte();
  87   5                          rsa_encrypt(data_in, &data_out, &key);  
  88   5                          // Send 2-byte ciphertext (MSB first)
  89   5                          uart_send_word(data_out);               
  90   5                      } 
  91   4                      else {
  92   5                          /* Decrypt Mode */
  93   5                          // Receive 2-byte ciphertext to decrypt
  94   5                          data_in = uart_receive_word();          
  95   5                          rsa_decrypt(data_in, &data_out, &key);  
  96   5                          // Send decrypted 2-byte word (since result can be up to 16-bit n)
  97   5                          uart_send_word(data_out);               
  98   5                      }
  99   4                  }
 100   3              }
 101   2          }
 102   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    220    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      7       6
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
