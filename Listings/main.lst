C51 COMPILER V9.60.7.0   MAIN                                                              12/22/2025 20:47:07 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\main
                    -.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          #include <reg51.h>
   2          #include "uart.h"
   3          #include "RSA.h"
   4          #include "math.h"
   5          #include "config.h"
   6          
   7          /* ================= Hardware Definitions ================= */
   8          sbit S0 = P3^3;              // Mode bit 0
   9          sbit S1 = P3^4;              // Mode bit 1
  10          
  11          sbit ERROR_LED = P2^0;       // LED turns ON if primality (p, q) fails
  12          sbit E_ERROR_LED = P2^1;     // NEW: LED turns ON if public exponent (e) fails
  13          
  14          /* ================= Global Variables ================= */
  15          RSA_Key key;
  16          uint8_t setup_done = FALSE;   
  17          uint8_t e_sent = FALSE;       
  18          
  19          /* Function to handle Mode 00: Setup */
  20          /* Function to handle Mode 00: Setup */
  21          void handle_setup(void) {
  22   1          uint8_t p_val, q_val;
  23   1          
  24   1          if (setup_done == TRUE) {
  25   2              e_sent = FALSE; 
  26   2              return;
  27   2          }
  28   1      
  29   1          // 1. Loop for P
  30   1          while (1) {
  31   2              p_val = uart_receive_decimal();
  32   2              P0 = p_val;
  33   2              if (fermat_test(p_val) == TRUE) {
  34   3                  ERROR_LED = 0;      // P is valid
  35   3                  uart_send_byte('P'); // Acknowledge P is OK
  36   3                  uart_send_byte('\n');
  37   3                  break; 
  38   3              } else {
  39   3                  ERROR_LED = 1;      // P failed
  40   3                  uart_send_byte('R'); // Request retry for P
  41   3              }
  42   2          }
  43   1      
  44   1          // 2. Loop for Q
  45   1          while (1) {
  46   2              q_val = uart_receive_decimal(); 
  47   2              if (fermat_test(q_val) == TRUE) {
  48   3                  ERROR_LED = 0;      // Q is valid
  49   3                  uart_send_byte('Q'); // Acknowledge Q is OK
  50   3                  uart_send_byte('\n');
  51   3                  break; 
  52   3              } else {
  53   3                  ERROR_LED = 1;      // Q failed
  54   3                  uart_send_byte('R'); // Request retry for Q
C51 COMPILER V9.60.7.0   MAIN                                                              12/22/2025 20:47:07 PAGE 2   

  55   3              }
  56   2          }
  57   1      
  58   1          // 3. Loop for E and Key Generation
  59   1          while (1) {
  60   2              // Try to generate key using e from Port 1
  61   2              if (rsa_generate_key(p_val, q_val, &key) == TRUE) {
  62   3                  E_ERROR_LED = 0;      
  63   3                  uart_send_byte('O'); 
  64   3                  uart_send_byte('K');
  65   3                  uart_send_byte('\n'); 
  66   3                  setup_done = TRUE;
  67   3                  e_sent = FALSE;
  68   3                  break; 
  69   3              } else {
  70   3                  E_ERROR_LED = 1;      
  71   3                  uart_send_byte('E');  // Notify UART that Port P1 value is invalid
  72   3                  // In this version, we wait for the user to change P1 
  73   3                  // and perhaps send a dummy byte to trigger a re-check
  74   3                  uart_receive_byte(); 
  75   3              }
  76   2          }
  77   1      }
  78          
  79          void main(void) {
  80   1          uint16_t ciphertext, plaintext;
  81   1          uint8_t mode;
  82   1      
  83   1          uart_init();
  84   1          ERROR_LED = 0;
  85   1          E_ERROR_LED = 0; // Initialize second LED to OFF
  86   1      
  87   1          while (1) {
  88   2              mode = ((uint8_t)S1 << 1) | (uint8_t)S0;
  89   2      
  90   2              switch (mode) {
  91   3                  case 0: /* Mode 00: Setup */
  92   3                      handle_setup();
  93   3                      break;
  94   3                  
  95   3                  case 1: /* Mode 01: Send public exponent e */
  96   3                      if (setup_done && !e_sent) {
  97   4                          uart_send_word(key.e);
  98   4                          uart_send_byte('\n');
  99   4                          e_sent = TRUE; 
 100   4                      }
 101   3                      break;
 102   3      
 103   3                  case 2: /* Mode 10: Receive byte, decrypt, and send */
 104   3                      if (setup_done) {
 105   4                          ciphertext = (uint16_t)uart_receive_byte();
 106   4                          rsa_decrypt(ciphertext, &plaintext, &key);
 107   4                          uart_send_byte((uint8_t)plaintext);
 108   4                      }
 109   3                      break;
 110   3      
 111   3                  case 3: /* Mode 11: Receive 16-bit ciphertext, decrypt */
 112   3                      if (setup_done) {
 113   4                          ciphertext = uart_receive_word();
 114   4                          rsa_decrypt(ciphertext, &plaintext, &key);
 115   4                          uart_send_word(plaintext);
 116   4                      }
C51 COMPILER V9.60.7.0   MAIN                                                              12/22/2025 20:47:07 PAGE 3   

 117   3                      break;
 118   3              }
 119   2          }
 120   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    272    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      8       6
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
